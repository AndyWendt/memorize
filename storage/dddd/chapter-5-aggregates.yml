---

- question: "What are entities?"
  tags: [tactical]
  answer: >
    Entities are often mutable (though not of necessity) objects that are unique even when their values
    correalate to objects of the same type (in contrast to a value object).

- question: "What are the dangers of over-abstracting?"
  tags: []
  answer: |
    - The language of the abstractions does not match the language of the model.  This language will creep into the user domain.
    - Makes it difficult to model the individual types
    - Leads to a complex heirarchy and special cases
    - An excessive amount of code because you're trying to solve an unsolvable problem and attempting to solve future needs that are unknown

- question: "What are some examples of entities and why?"
  tags: []
  answer: |
    - Accounts
    - Invoices
    - Time Entries
    - Attachments
    - Posts
    - Tasks
    - Users

- question: "What are some examples of value objects and why?"
  tags: []
  answer: |
    - Tax Rates
    - Urls / Links
    - Addresses
    - Roles
    - Tags
    - Time

- question: "What are the steps/rules to creating a right-sized aggregate?"
  tags: []
  answer: >
    1. start off by designing small, cohesive aggregates by creating one entity per aggregate and making it the root.

- question: "What are the rules of Aggregate design?"
  tags: []
  answer: |
    1. Protect business invariants inside Aggregate boundaries
    2. Design small Aggregates.
    3. Reference Other Aggregates by Identity Only
    4. Update Other Aggregates Using Eventual Consistency

- question: "Describe the first rule of aggregate design"
  tags: []
  answer: >
    The business should ultimately determine Aggregate compositions based on what must
    be consistent when a transaction is committed.

- question: "Describe the second rule of aggregate design"
  tags: []
  answer: >
    The memory footprint and transactional scope of each Aggregate should be relatively small. Whenever needed,
    break up larger aggregates into smaller aggregates so that each Aggregate will be easier to work on.
    If your Aggregate is trying to do too many things, it is not following SRP.

- question: "Describe the third rule of aggregate design"
  tags: []
  answer: >
    This helps keep Aggregates small and prevents reaching out to modify multiple Aggregates in the same transaction.

- question: "Describe the fourth rule of aggregate design"
  tags: []
  answer: "foo 4"

- question: "Describe the fifth rule of aggregate design"
  tags: []
  answer: >
    Other aggregates should be eventually consistent with the aggregate that you're currently updating.

- question: "Describe an Anemic Domain Model"
  tags: []
  answer: >
    Where all of your Aggregates have only public accessors but no real business behavior.  All of the overhead with
    none of the benefits.  Business logic can also leak into the Application Services above your model.
