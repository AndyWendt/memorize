---

- question: "When code depends on a hash value being present, nested or not, how should you retrieve the value and WHY?"
  answer: |
    A regular hash call without a key present returns `nil`.  A chained call will return
      `NoMethodError (undefined method [] for nil:NilClass)`.  Unfortunately, it fails far away from where
      the values are added to the hash.
    Using `Hash#fetch()` raises a `key not found error`  Raises the error right where the information is supplied.
  tags: []

- question: "What is the search sequence when attempting to find a symbol in Ruby?"
  answer: |
    1. Each entry in `Module.nesting`
    2. Each entry in `Module.nesting.first.ancestors`
    3. Each entry in `Object.ancestors` if `Module.nesting.first` is `nil` or a module.
  tags: []

- question: "Explain Ruby Contant Lookup"
  answer: |
    Loosely speaking, the search first works upwards through the nesting at the point of reference,
    then upwards through either the inheritance chain of the containing class (if there is one), or
    that of `Object` otherwise.
  tags: []

- question: "Explain when and why you should use the symbolic or english-style boolean operators"
  answer: |
    The english-style variants have a much lower operator precedence and thus the results are often unexpected.
    In addition, the english-style variants have equal precedence and are thus evaluated left to right.

    For instance:

    ```
        user = Struct.new(:name).new("avdi")
        user_name = user && user.name
        user_name # 'avdi'
        user_name = user and user.name
        user_name # <struct name="avdi">
    ```

    In the above example, it is assigning `user` to `user_name` first and then attempting to retrieve the name
    property.

    Ruby inherits the english-style operators from Perl where their purpose is to control flow.
    As in, do something _or_ die.  Thus it means, only execute the code on the right if the code
    on the left is falsey. Or with an `and`, only execute the code on the right
    if the code on the left is truthy.
  tags: []


- question: What is `object.tap`'s purpose and usage?
  answer: |
    It's used to modify the current object and return the result as the current object and NOT the assigned value

    For example:

    ```
    def fizz_factory_1
      fizz_object = Struct.new(:fizz).new
      fizz_object.fizz = 'foo'
      fizz_object
    end

    def fizz_factory_2
      Struct.new(:fizz).new.tap { |obj|  obj.fizz = 'foo' }
    end

    fizz_factory_1.fizz == fizz_factory_2.fizz # true
    ```
  tags: []
